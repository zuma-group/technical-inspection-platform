name: Main Production CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd "pg_isready -U postgres -d postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 18
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Setup TEST environment variables
      run: |
        echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/postgres" >> $GITHUB_ENV
        echo "JWT_SECRET=test-secret-for-ci-only" >> $GITHUB_ENV
        echo "NODE_ENV=test" >> $GITHUB_ENV

    - name: Debug environment
      run: |
        echo "üîç Environment variables:"
        echo "DATABASE_URL=$DATABASE_URL"
        echo "NODE_ENV=$NODE_ENV"
        echo "üîç PostgreSQL connection test:"
        pg_isready -h localhost -p 5432 -U postgres
        echo "üîç Test direct connection:"
        PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres -d postgres -c "SELECT 1"

    - name: Generate Prisma client
      run: npx prisma generate

    - name: Run linting
      run: npm run lint

    # Replace single migrate step with migrate+push to ensure schema exists for seeding
    - name: Ensure database schema (migrate or push)
      run: |
        set -e
        echo "üóÑÔ∏è  Applying migrations (if any)..."
        npx prisma migrate deploy || true
        echo "üß± Ensuring schema via db push..."
        npx prisma db push

    - name: Seed database
      run: node prisma/seed.js

    # - name: Run tests
    #   run: npm test

    - name: Build application
      run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main') && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Create deployment package
      run: |
        # Create tar in temp dir to avoid "file changed as we read it" when writing into '.'
        TMP_TAR="$RUNNER_TEMP/deployment.tar.gz"
        tar -czf "$TMP_TAR" \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='.next' \
          --exclude='coverage' \
          --exclude='*.log' \
          -C "$GITHUB_WORKSPACE" .
        mv "$TMP_TAR" "$GITHUB_WORKSPACE/deployment.tar.gz"
    
    - name: Validate deploy secrets
      run: |
        set -euo pipefail
        fail=false
        [ -n "${{ secrets.PROD_EC2_HOST }}" ] || { echo "‚ùå Missing secret: PROD_EC2_HOST"; fail=true; }
        [ -n "${{ secrets.PROD_EC2_USER }}" ] || { echo "‚ùå Missing secret: PROD_EC2_USER"; fail=true; }
        if [ -z "${{ secrets.PROD_EC2_SSH_KEY }}" ]; then
          echo "‚ùå Missing secret: PROD_EC2_SSH_KEY"
          fail=true
        else
          echo "‚úÖ SSH key present"
        fi
        if [ "$fail" = true ]; then exit 1; fi
          
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PROD_EC2_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PROD_EC2_HOST }} >> ~/.ssh/known_hosts

    - name: Copy deployment package to server
      run: |
        set -euo pipefail
        PORT_OPT=""
        if [ -n "${{ secrets.PROD_EC2_SSH_PORT }}" ]; then PORT_OPT="-P ${{ secrets.PROD_EC2_SSH_PORT }}"; fi
        scp -i ~/.ssh/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no $PORT_OPT deployment.tar.gz ${{ secrets.PROD_EC2_USER }}@${{ secrets.PROD_EC2_HOST }}:/tmp/deployment.tar.gz

    - name: Deploy to Production EC2
      run: |
        set -euo pipefail
        PORT_OPT=""
        if [ -n "${{ secrets.PROD_EC2_SSH_PORT }}" ]; then PORT_OPT="-p ${{ secrets.PROD_EC2_SSH_PORT }}"; fi
        ssh -i ~/.ssh/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no $PORT_OPT ${{ secrets.PROD_EC2_USER }}@${{ secrets.PROD_EC2_HOST }} << 'EOF'
          set -euo pipefail
          # Setup deployment from uploaded package
          APP_DIR="$HOME/technical-inspection-platform-prod"
          ENV_BACKUP="/tmp/.env.backup"
          
          # Backup .env file if it exists
          if [ -f "$APP_DIR/.env" ]; then
            echo "üíæ Backing up .env file..."
            cp "$APP_DIR/.env" "$ENV_BACKUP"
          fi
          
          # Clean up old deployment and create fresh directory
          echo "üßπ Cleaning up old deployment..."
          rm -rf "$APP_DIR"
          mkdir -p "$APP_DIR"
          
          # Extract new deployment
          echo "üì¶ Extracting deployment package..."
          cd "$APP_DIR"
          tar -xzf /tmp/deployment.tar.gz
          
          # Restore .env file if we had a backup
          if [ -f "$ENV_BACKUP" ]; then
            echo "üìÅ Restoring .env file..."
            cp "$ENV_BACKUP" .env
            rm "$ENV_BACKUP"
          fi
          
          # Verify we're in the right directory and files exist
          echo "üìÅ Current directory: $(pwd)"
          echo "üìã Key files check:"
          ls -la docker-compose.postgres.yml .env 2>/dev/null || echo "Some files missing"
          
          # Check if .env exists
          if [ ! -f .env ]; then
            echo "‚ùå Error: .env file not found on server!"
            echo "Please create production .env file on EC2 server first"
            echo "Expected location: $(pwd)/.env"
            exit 1
          fi
          
          # Check if docker-compose file exists
          if [ ! -f docker-compose.postgres.yml ]; then
            echo "‚ùå Error: docker-compose.postgres.yml not found!"
            echo "Repository may be incomplete"
            exit 1
          fi
          
          # Stop current application
          echo "üõë Stopping current containers..."
          docker compose -f docker-compose.postgres.yml down || true
          
          # Check for port conflicts (using port 3002 for production)
          echo "üîç Checking for port conflicts..."
          USED_PORTS=$(docker ps --format '{{.Ports}}' | grep -oP '\\d+(?=->)' | sort -n | uniq || echo "")
          if echo "$USED_PORTS" | grep -q "3002"; then
           echo "‚ùå Port 3002 is already in use!"
           echo "Used ports: $USED_PORTS"
           echo "Please stop the conflicting service or update docker-compose.postgres.yml to use a different port"
           exit 1
          fi
          echo "‚úÖ Port 3002 is available"
          
          # Rebuild and restart containers
          echo "üî® Building and starting containers..."
          echo "üî® Starting Docker build (this may take several minutes)..."
          
          # Build in background and monitor
          nohup docker compose -f docker-compose.postgres.yml build --progress=plain > /tmp/docker-build.log 2>&1 &
          BUILD_PID=$!
          
          # Monitor the build process
          echo "üî® Build started with PID: $BUILD_PID"
          for i in {1..60}; do
            if ! kill -0 $BUILD_PID 2>/dev/null; then
              echo "üî® Build completed!"
              break
            fi
            echo "üî® Build in progress... (${i}/60)"
            sleep 10
          done
          
          # Check if build was successful
          wait $BUILD_PID
          BUILD_EXIT_CODE=$?
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Docker build failed with exit code: $BUILD_EXIT_CODE"
            echo "üìã Build logs:"
            tail -50 /tmp/docker-build.log
            exit 1
          fi
          
          # Build completed successfully

          # Run Prisma migrations on the server using the freshly built app image
          echo "üóÑÔ∏è  Applying Prisma migrations..."
          docker compose -f docker-compose.postgres.yml run --rm app npx prisma migrate deploy

          echo "üöÄ Starting app..."
          docker compose -f docker-compose.postgres.yml up -d --force-recreate --remove-orphans
          
          sleep 10
          echo "‚è≥ Almost ready..."
          sleep 5
          
          # Check if application is running
          echo "üîç Checking container status..."
          docker compose -f docker-compose.postgres.yml ps
          
          # Look for "Up" instead of "running"
          if docker compose -f docker-compose.postgres.yml ps | grep -q "Up"; then
            echo "‚úÖ Deployment successful!"
            echo "üîç Container status:"
            docker compose -f docker-compose.postgres.yml ps
            
          # Test if the app responds
          echo "üåê Testing application response..."
          sleep 5
          if curl -f http://localhost:3002/ >/dev/null 2>&1; then
           echo "‚úÖ Application is responding!"
          else
           echo "‚ö†Ô∏è  Application might still be starting up"
          fi
          else
            echo "‚ùå Deployment failed!"
            echo "üìã Container logs:"
            echo "üìã Recent app logs:"
            docker compose -f docker-compose.postgres.yml logs --tail=200 app || true
            docker compose -f docker-compose.postgres.yml logs
            exit 1
          fi
        EOF

  notify:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "üéâ Production deployment to EC2 successful!"
        else
          echo "üí• Production deployment to EC2 failed!"
        fi

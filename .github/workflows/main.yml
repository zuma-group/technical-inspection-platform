name: Main Production CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd "pg_isready -U postgres -d postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 18
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Setup TEST environment variables
      run: |
        echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/postgres" >> $GITHUB_ENV
        echo "JWT_SECRET=test-secret-for-ci-only" >> $GITHUB_ENV
        echo "NODE_ENV=test" >> $GITHUB_ENV

    - name: Debug environment
      run: |
        echo "ğŸ” Environment variables:"
        echo "DATABASE_URL=$DATABASE_URL"
        echo "NODE_ENV=$NODE_ENV"
        echo "ğŸ” PostgreSQL connection test:"
        pg_isready -h localhost -p 5432 -U postgres
        echo "ğŸ” Test direct connection:"
        PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres -d postgres -c "SELECT 1"

    - name: Generate Prisma client
      run: npx prisma generate

    - name: Run linting
      run: npm run lint

    # Replace single migrate step with migrate+push to ensure schema exists for seeding
    - name: Ensure database schema (migrate or push)
      run: |
        set -e
        echo "ğŸ—„ï¸  Applying migrations (if any)..."
        npx prisma migrate deploy || true
        echo "ğŸ§± Ensuring schema via db push..."
        npx prisma db push

    - name: Seed database
      run: node prisma/seed.js

    # - name: Run tests
    #   run: npm test

    - name: Build application
      run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main') && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Create deployment package
      run: |
        # Create a tar package excluding unnecessary files
        tar -czf deployment.tar.gz \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='.next' \
          --exclude='coverage' \
          --exclude='*.log' \
          .
          
    - name: Upload deployment package to Production EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.PROD_EC2_HOST }}
        username: ${{ secrets.PROD_EC2_USER }}
        key: ${{ secrets.PROD_EC2_SSH_KEY }}
        source: "deployment.tar.gz"
        target: "/tmp/"
        
    - name: Deploy to Production EC2
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_EC2_HOST }}
        username: ${{ secrets.PROD_EC2_USER }}
        key: ${{ secrets.PROD_EC2_SSH_KEY }}
        timeout: 300s
        command_timeout: 60m
        sync: true
        script: |
          # Setup deployment from uploaded package
          APP_DIR="/home/ubuntu/technical-inspection-platform-prod"
          ENV_BACKUP="/tmp/.env.backup"
          
          # Backup .env file if it exists
          if [ -f "$APP_DIR/.env" ]; then
            echo "ğŸ’¾ Backing up .env file..."
            cp "$APP_DIR/.env" "$ENV_BACKUP"
          fi
          
          # Clean up old deployment and create fresh directory
          echo "ğŸ§¹ Cleaning up old deployment..."
          rm -rf "$APP_DIR"
          mkdir -p "$APP_DIR"
          
          # Extract new deployment
          echo "ğŸ“¦ Extracting deployment package..."
          cd "$APP_DIR"
          tar -xzf /tmp/deployment.tar.gz
          
          # Restore .env file if we had a backup
          if [ -f "$ENV_BACKUP" ]; then
            echo "ğŸ“ Restoring .env file..."
            cp "$ENV_BACKUP" .env
            rm "$ENV_BACKUP"
          fi
          
          # Verify we're in the right directory and files exist
          echo "ğŸ“ Current directory: $(pwd)"
          echo "ğŸ“‹ Key files check:"
          ls -la docker-compose.postgres.yml .env 2>/dev/null || echo "Some files missing"
          
          # Check if .env exists
          if [ ! -f .env ]; then
            echo "âŒ Error: .env file not found on server!"
            echo "Please create production .env file on EC2 server first"
            echo "Expected location: $(pwd)/.env"
            exit 1
          fi
          
          # Check if docker-compose file exists
          if [ ! -f docker-compose.postgres.yml ]; then
            echo "âŒ Error: docker-compose.postgres.yml not found!"
            echo "Repository may be incomplete"
            exit 1
          fi
          
          # Stop current application
          echo "ğŸ›‘ Stopping current containers..."
          docker compose -f docker-compose.postgres.yml down || true
          
          # Check for port conflicts (using port 3002 for production)
          echo "ğŸ” Checking for port conflicts..."
          USED_PORTS=$(docker ps --format '{{.Ports}}' | grep -oP '\d+(?=->)' | sort -n | uniq || echo "")
          if echo "$USED_PORTS" | grep -q "3002"; then
           echo "âŒ Port 3002 is already in use!"
           echo "Used ports: $USED_PORTS"
           echo "Please stop the conflicting service or update docker-compose.postgres.yml to use a different port"
           exit 1
          fi
          echo "âœ… Port 3002 is available"
          
          # Rebuild and restart containers
          echo "ğŸ”¨ Building and starting containers..."
          echo "ğŸ”¨ Starting Docker build (this may take several minutes)..."
          
          # Build in background and monitor
          nohup docker compose -f docker-compose.postgres.yml build --progress=plain > /tmp/docker-build.log 2>&1 &
          BUILD_PID=$!
          
          # Monitor the build process
          echo "ğŸ”¨ Build started with PID: $BUILD_PID"
          for i in {1..60}; do
            if ! kill -0 $BUILD_PID 2>/dev/null; then
              echo "ğŸ”¨ Build completed!"
              break
            fi
            echo "ğŸ”¨ Build in progress... (${i}/60)"
            sleep 10
          done
          
          # Check if build was successful
          wait $BUILD_PID
          BUILD_EXIT_CODE=$?
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "âŒ Docker build failed with exit code: $BUILD_EXIT_CODE"
            echo "ğŸ“‹ Build logs:"
            tail -50 /tmp/docker-build.log
            exit 1
          fi
          
          docker compose -f docker-compose.postgres.yml up -d
          
          # Clean up SSH key
          rm -f ~/.ssh/deploy_key
          
          # Wait for containers to start
          echo "â³ Waiting for containers to start..."
          sleep 10
          echo "â³ Still waiting..."
          sleep 10
          echo "â³ Almost ready..."
          sleep 5
          
          # Check if application is running
          echo "ğŸ” Checking container status..."
          docker compose -f docker-compose.postgres.yml ps
          
          # Look for "Up" instead of "running"
          if docker compose -f docker-compose.postgres.yml ps | grep -q "Up"; then
            echo "âœ… Deployment successful!"
            echo "ğŸ” Container status:"
            docker compose -f docker-compose.postgres.yml ps
            
          # Test if the app responds
          echo "ğŸŒ Testing application response..."
          sleep 5
          if curl -f http://localhost:3002/ >/dev/null 2>&1; then
           echo "âœ… Application is responding!"
          else
           echo "âš ï¸  Application might still be starting up"
          fi
          else
            echo "âŒ Deployment failed!"
            echo "ğŸ“‹ Container logs:"
            docker compose -f docker-compose.postgres.yml logs
            exit 1
          fi

  notify:
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "ğŸ‰ Production deployment to EC2 successful!"
        else
          echo "ğŸ’¥ Production deployment to EC2 failed!"
        fi
